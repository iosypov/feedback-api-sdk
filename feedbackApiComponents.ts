/**
 * Generated by @openapi-codegen
 *
 * @version 1.0
 */
import * as reactQuery from '@tanstack/react-query';
import { useFeedbackApiContext, FeedbackApiContext } from './feedbackApiContext';
import type * as Fetcher from './feedbackApiFetcher';
import { feedbackApiFetch } from './feedbackApiFetcher';
import type * as Schemas from './feedbackApiSchemas';
import type * as Responses from './feedbackApiResponses';

export type GetFeedbackPathParams = {
  /**
   * Resource identifier string.
   *
   * @pattern ^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$
   * @example c73bcdcc-2669-4bf6-81d3-e4ae73fb11fd
   */
  id: string;
};

export type GetFeedbackError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequest;
    }
  | {
      status: 401;
      payload: Responses.Unauthorized;
    }
  | {
      status: 404;
      payload: Responses.NotFound;
    }
  | {
      status: 429;
      payload: Responses.TooManyRequests;
    }
  | {
      status: 500;
      payload: Responses.InternalServerError;
    }
>;

export type GetFeedbackVariables = {
  pathParams: GetFeedbackPathParams;
} & FeedbackApiContext['fetcherOptions'];

export const fetchGetFeedback = (variables: GetFeedbackVariables, signal?: AbortSignal) =>
  feedbackApiFetch<Schemas.Feedback, GetFeedbackError, undefined, {}, {}, GetFeedbackPathParams>({
    url: '/feedback/{id}',
    method: 'get',
    ...variables,
    signal,
  });

export const useGetFeedback = <TData = Schemas.Feedback>(
  variables: GetFeedbackVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.Feedback, GetFeedbackError, TData>,
    'queryKey' | 'queryFn'
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useFeedbackApiContext(options);
  return reactQuery.useQuery<Schemas.Feedback, GetFeedbackError, TData>(
    queryKeyFn({ path: '/feedback/{id}', operationId: 'getFeedback', variables }),
    ({ signal }) => fetchGetFeedback({ ...fetcherOptions, ...variables }, signal),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type UpdateFeedbackPathParams = {
  /**
   * Resource identifier string.
   *
   * @pattern ^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$
   * @example c73bcdcc-2669-4bf6-81d3-e4ae73fb11fd
   */
  id: string;
};

export type UpdateFeedbackError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequest;
    }
  | {
      status: 401;
      payload: Responses.Unauthorized;
    }
  | {
      status: 404;
      payload: Responses.NotFound;
    }
  | {
      status: 429;
      payload: Responses.TooManyRequests;
    }
  | {
      status: 500;
      payload: Responses.InternalServerError;
    }
>;

export type UpdateFeedbackVariables = {
  body?: Schemas.Feedback;
  pathParams: UpdateFeedbackPathParams;
} & FeedbackApiContext['fetcherOptions'];

export const fetchUpdateFeedback = (variables: UpdateFeedbackVariables, signal?: AbortSignal) =>
  feedbackApiFetch<
    Schemas.Feedback,
    UpdateFeedbackError,
    Schemas.Feedback,
    {},
    {},
    UpdateFeedbackPathParams
  >({ url: '/feedback/{id}', method: 'put', ...variables, signal });

export const useUpdateFeedback = (
  options?: Omit<
    reactQuery.UseMutationOptions<Schemas.Feedback, UpdateFeedbackError, UpdateFeedbackVariables>,
    'mutationFn'
  >
) => {
  const { fetcherOptions } = useFeedbackApiContext();
  return reactQuery.useMutation<Schemas.Feedback, UpdateFeedbackError, UpdateFeedbackVariables>(
    (variables: UpdateFeedbackVariables) =>
      fetchUpdateFeedback({ ...fetcherOptions, ...variables }),
    options
  );
};

export type GetFeedbacksQueryParams = {
  /**
   * Rating to filter by.
   */
  rating?: number[];
  /**
   * Sentiment to filter by.
   */
  sentiment?: (true | false)[];
  /**
   * Reasons to filter by.
   */
  reasons?: string[];
  /**
   * User ID to filter by.
   */
  userId?: string[];
  /**
   * IP address to filter by.
   */
  userIP?: string[];
  /**
   * Page to filter by.
   */
  page?: string[];
  /**
   * Category to filter by.
   */
  category?: string[];
  /**
   * Operation to filter by.
   */
  apiOperationId?: string[];
};

export type GetFeedbacksHeaders = {
  /**
   * Page number.
   *
   * @default 1
   * @example 1
   */
  ['X-PAGE']?: number;
  /**
   * Items per page.
   *
   * @default 50
   * @example 10
   */
  ['X-PER-PAGE']?: number;
  /**
   * Sort order.
   *
   * @default desc
   */
  ['X-ORDER']?: 'asc' | 'desc';
  /**
   * Order by.
   *
   * @default createdAt
   */
  ['X-ORDER-BY']?: 'rating' | 'createdAt';
};

export type GetFeedbacksError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Responses.Unauthorized;
    }
  | {
      status: 429;
      payload: Responses.TooManyRequests;
    }
  | {
      status: 500;
      payload: Responses.InternalServerError;
    }
>;

export type GetFeedbacksResponse = {
  data?: Schemas.Feedback[];
  pagination?: Schemas.Pagination;
};

export type GetFeedbacksVariables = {
  headers?: GetFeedbacksHeaders;
  queryParams?: GetFeedbacksQueryParams;
} & FeedbackApiContext['fetcherOptions'];

export const fetchGetFeedbacks = (variables: GetFeedbacksVariables, signal?: AbortSignal) =>
  feedbackApiFetch<
    GetFeedbacksResponse,
    GetFeedbacksError,
    undefined,
    GetFeedbacksHeaders,
    GetFeedbacksQueryParams,
    {}
  >({ url: '/feedback', method: 'get', ...variables, signal });

export const useGetFeedbacks = <TData = GetFeedbacksResponse>(
  variables: GetFeedbacksVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<GetFeedbacksResponse, GetFeedbacksError, TData>,
    'queryKey' | 'queryFn'
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useFeedbackApiContext(options);
  return reactQuery.useQuery<GetFeedbacksResponse, GetFeedbacksError, TData>(
    queryKeyFn({ path: '/feedback', operationId: 'getFeedbacks', variables }),
    ({ signal }) => fetchGetFeedbacks({ ...fetcherOptions, ...variables }, signal),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type CreateFeedbackError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequest;
    }
  | {
      status: 401;
      payload: Responses.Unauthorized;
    }
  | {
      status: 429;
      payload: Responses.TooManyRequests;
    }
  | {
      status: 500;
      payload: Responses.InternalServerError;
    }
>;

export type CreateFeedbackVariables = {
  body?: Schemas.Feedback;
} & FeedbackApiContext['fetcherOptions'];

export const fetchCreateFeedback = (variables: CreateFeedbackVariables, signal?: AbortSignal) =>
  feedbackApiFetch<Schemas.Feedback, CreateFeedbackError, Schemas.Feedback, {}, {}, {}>({
    url: '/feedback',
    method: 'post',
    ...variables,
    signal,
  });

export const useCreateFeedback = (
  options?: Omit<
    reactQuery.UseMutationOptions<Schemas.Feedback, CreateFeedbackError, CreateFeedbackVariables>,
    'mutationFn'
  >
) => {
  const { fetcherOptions } = useFeedbackApiContext();
  return reactQuery.useMutation<Schemas.Feedback, CreateFeedbackError, CreateFeedbackVariables>(
    (variables: CreateFeedbackVariables) =>
      fetchCreateFeedback({ ...fetcherOptions, ...variables }),
    options
  );
};

export type HealthError = Fetcher.ErrorWrapper<
  | {
      status: 429;
      payload: Responses.TooManyRequests;
    }
  | {
      status: 500;
      payload: Responses.InternalServerError;
    }
>;

export type HealthVariables = FeedbackApiContext['fetcherOptions'];

export const fetchHealth = (variables: HealthVariables, signal?: AbortSignal) =>
  feedbackApiFetch<Responses.NoContent, HealthError, undefined, {}, {}, {}>({
    url: '/health',
    method: 'get',
    ...variables,
    signal,
  });

export const useHealth = <TData = Responses.NoContent>(
  variables: HealthVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Responses.NoContent, HealthError, TData>,
    'queryKey' | 'queryFn'
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useFeedbackApiContext(options);
  return reactQuery.useQuery<Responses.NoContent, HealthError, TData>(
    queryKeyFn({ path: '/health', operationId: 'health', variables }),
    ({ signal }) => fetchHealth({ ...fetcherOptions, ...variables }, signal),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type QueryOperation =
  | {
      path: '/feedback/{id}';
      operationId: 'getFeedback';
      variables: GetFeedbackVariables;
    }
  | {
      path: '/feedback';
      operationId: 'getFeedbacks';
      variables: GetFeedbacksVariables;
    }
  | {
      path: '/health';
      operationId: 'health';
      variables: HealthVariables;
    };
